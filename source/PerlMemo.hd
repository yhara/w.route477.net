!!接頭辞
||スカラー(数値or文字列)||$num, $str||
||配列||@arr||
||ハッシュ||%hash||
||サブルーチン||&subr||
||型グロブ||*struck||

!!文字列リテラル
||ダブルクオート||変数の展開・バックスラッシュが有効||
||シングルクオート|| 〃 無効||
||バッククオート||コマンドを実行した結果の文字列||


!!配列リテラル
 @arr = (1, 2, 3);
参照は下のように$で始める（配列の「中身」は常にスカラーなので）。
 $arr[1]

下のように括弧を省略した場合でも、printの引数は配列と見なされる。
 print 1, 2, 3;

!!ハッシュリテラル
 %hash = ("Sun" => "Sunday", "Mon" => "Monday");
参照は$で始める
 $hash{"Sun"}

!!多重代入
 ($a, $b, $c, $d) = @arr;
 ($a, $b) = ($c, $d);

!!ファイル操作
ファイルハンドルというものを使う。
 open(FOO, "foo.txt");
読み込みはファイルハンドルに対して<>という行入力演算子を使う。
 $line = <FOO>;
$lineには(末尾の改行を含む)文字列が代入される。

||読み込み|| "<foo.txt" もしくは単に "foo.txt"||
||書き込み|| ">foo.txt"||
||追加 ||">>foo.txt"||
||外部プログラムへ出力|| "| cmd"||
||外部プログラムから入力|| "cmd |"||

ファイルのテストには演算子を使う。
||-e $a||exist||
||-r $a||readable||
||-w $a||writable||
||-d $a||directory||
||-f $a||file (普通のファイル)||
||-T $a||text file||


!演算子

!!四則演算
文字列の連結には + ではなく . を使う。
 $a = 123;
 $b = 456;
 print $a + $b; #=> 579
 print $a . $b; #=> 123456
文字列の繰り返しには * ではなく x を使う。
 $a = 123;
 $b = 2;
 print $a * $b; #=> 246
 print $a x $b; #=> 123123
上から分かるように、数値と文字列は暗黙的に変換される。

「.=」とか「x=」という演算子もある。

!!比較
文字列の比較には ==, !=, <, >, <=の代わりにeq, ne, lt, gt, leを使う。

Rubyの<=>は 数値は<=>、文字列はcmp

!!インクリメント・デクリメント
C言語と同じく++$a, $a++, --$a, $a--の4種類が用意されている。

!!論理演算子
&&, ||, ! もしくは and, or, not。Rubyと同じく後者の方が優先順位が低い。

!制御構文

!!真偽値
真偽は常にスカラーコンテキストで評価される。

偽であるものは数値の0、文字列の""と"0"、未定義値で、それ以外は全て真である。

!!条件分岐
C言語と違い、if(unless), elsif, elseの中括弧は省略できない。(if文はブロックを実行すると定義されているので)
 if($a > 0) {
   print "plus";
 }
 elsif($a < 0){
   print "minus";
 }
 else{
   print "zero";
 }

!!繰り返し
!!!while, until
C言語と違い、while(until)の中括弧は省略できない。

ファイルの各行を出力する処理は以下のように書ける。
 while($line = <FOO>){
   print $line;
 }
ファイルの末尾に達すると <FOO> は未定義値を返すので、ループは終了する。

条件に配列を書くと、「配列のサイズが0になるまで」という意味になる(配列はスカラーコンテキストでは要素の個数を返すので)。
 while(@ARGV){
   process(shift @ARGV);
 }

!!!for
for文はC言語と同じような働きをする。
 for($i = 0; $i < 100; $i++){
  ...
 }

!!!foreach
foreachはリストの各要素に対して繰り返すのに使われる。
 foreach $user (@users) {
   print $user;
 }
このとき$userは要素のコピーではなく、要素そのもののリファレンスになる(らしい)。
$userに代入すると、元の配列@usersの要素も書き換わる。

!!!next, last
Rubyのnext, continue, breakはそれぞれnext, last, breakに対応する。

C言語では、多重ループを一気に抜けるときにgotoが使える。
Perlにgotoはないが、代わりにループの初めにラベルを指定する機能がある。
 LINE:
 while ($line = <FOO>) {
   last LINE if $line eq "\n";
   ..
 }

!1.7 正規表現
あとで。
